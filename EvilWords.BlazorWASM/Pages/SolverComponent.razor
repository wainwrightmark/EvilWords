@using MudBlazor
@using System.Collections.Concurrent
@using System.Collections.Immutable
@using System.Text.Json
@using BlazorWorker.BackgroundServiceFactory
@using BlazorWorker.Core
@using BlazorWorker.WorkerBackgroundService
@implements IDisposable;
@inject IWorkerFactory _workerFactory

<MudList>
    @for (var guessResultIndex = 0; guessResultIndex < GameState.PreviousGuesses.Count; guessResultIndex++)
    {
        var guessResult = GameState.PreviousGuesses[guessResultIndex];
        var gri = guessResultIndex;

        <MudListItem>

            @for (var charResultIndex = 0; charResultIndex < guessResult.Results.Count; charResultIndex++)
            {
                var cri = charResultIndex;
                var charResult = guessResult.Results[charResultIndex];

                <MudButton
                    Color="charResult.ResultColor.GetColor()"
                    Variant="Variant.Filled"
                    OnClick="() => CycleResult(gri, cri)">
                    @charResult.Character
                </MudButton>
            }
            <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="() => RemoveGuesses(gri)"/>

        </MudListItem>
    }


    <MudListItem>

        <MudButtonGroup>
            <MudTextField
                @bind-Value="UserGuess"
                MaxLength="@Settings.WordLength"
                Placeholder="@(Suggestion?.BestWord ?? "")"
                HelperText="@(Suggestion?.PossibilityText)"
                InputMode="InputMode.text"
                InputType="InputType.Text"
                Immediate="true"
                Pattern="@Settings.Pattern"
                Style="width: fit-content"/>
            <MudIconButton
                Icon="@Icons.Filled.Add"
                OnClick="AddGuess"
                Disabled="!IsGoodGuess()"/>
        </MudButtonGroup>


    </MudListItem>


</MudList>


@code{
    public GameState GameState { get; set; } = new(ImmutableArray<GuessResult>.Empty);

    public GameSettings Settings { get; } = GameSettings.FiveLetter;

    private (IWorker Worker, IWorkerBackgroundService<SolverService> Service)? Worker { get; set; }

    private string _userGuess = "";

    public string UserGuess
    {
        get => _userGuess;
        set => _userGuess = value.ToUpperInvariant();
    }

    /// <inheritdoc />
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        if (Worker is null)
        {
            var worker = await _workerFactory.CreateAsync();
            var service = await worker.CreateBackgroundServiceAsync<SolverService>(
                x => x
                    .AddConventionalAssemblyOfService()
                    .AddAssemblyOf<Generator.Equals.EquatableAttribute>()
                    .AddAssemblies("Microsoft.Bcl.HashCode.dll", "System.Linq.Parallel.dll", "System.Diagnostics.Tracing.dll")
                );

            Worker = (worker, service);

            StateChanged();
        }
    }

    public void RemoveGuesses(int index)
    {
        GameState = new GameState(GameState.PreviousGuesses.Take(index).ToImmutableArray());
        StateChanged();
    }

    public int StochasticSize { get; set; } = 20;

    public Random Random = new();


    private readonly record struct SuggestionData(string BestWord, IReadOnlyList<string> RemainingPossibilities)
    {
        public string PossibilityText
        {
            get
            {
                if (RemainingPossibilities.Count == 0)
                    return "No Possible Solutions";
                else if (RemainingPossibilities.Count == 1)
                    return "Only Solution";
                else if (RemainingPossibilities.Count <= 4)
                    return $"'{string.Join(", ", RemainingPossibilities)}'";
                else return $"{RemainingPossibilities.Count} Possible Solutions";
            }
        }
    };

    private SuggestionData? Suggestion { get; set; } = null;

    public string? GetRealGuess()
    {
        var guess = UserGuess;
        if (string.IsNullOrWhiteSpace(guess))
            guess = Suggestion?.BestWord;
        if (guess is null)
            return null;

        guess = new string(guess.Trim().ToUpperInvariant().Where(char.IsLetter).ToArray());

        if (guess.Length != Settings.WordLength || !Settings.PossibleGuesses.Contains(guess))
            return null;

        return guess;
    }

    public bool IsGoodGuess() => GetRealGuess() is not null;

    private void AddGuess()
    {
        var guess = GetRealGuess();
        if (guess is null) return;

        var newGuessResult = GuessResult.GetWorstCase(guess, GameState, Settings);

        GuessResult.ScoreWord(guess, guess); //assume guess was correct
        GameState = GameState.Add(newGuessResult);
        UserGuess = "";
        StateChanged();
    }

    private void ChangeChar(char newCharacter, int resultIndex, int charIndex)
    {
        var guess = GameState.PreviousGuesses[resultIndex];
        var character = guess.Results[charIndex];

        var newChr = character with{Character = newCharacter};
        var newResults = guess.Results.ToList();
        newResults[charIndex] = newChr;

        var newGuess = guess with{Results = newResults};
        var newGameState = GameState with{PreviousGuesses = GameState.PreviousGuesses.ToImmutableList().SetItem(resultIndex, newGuess)};

        GameState = newGameState;

        StateChanged();
    }

    private void CycleResult(int resultIndex, int charIndex)
    {
        var guess = GameState.PreviousGuesses[resultIndex];
        var character = guess.Results[charIndex];

        var newChr = character with{ResultColor = character.ResultColor.CycleToNext()};
        var newResults = guess.Results.ToList();
        newResults[charIndex] = newChr;

        var newGuess = guess with{Results = newResults};
        var newGameState = GameState with{PreviousGuesses = GameState.PreviousGuesses.ToImmutableList().SetItem(resultIndex, newGuess)};

        GameState = newGameState;

        StateChanged();
    }

    private CancellationTokenSource? _cancellationTokenSource;

    private async Task StateChanged()
    {
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource = new CancellationTokenSource();
        Suggestion = null;
        StateHasChanged();

        if (!Worker.HasValue)
            return;

        var serializedGameState = GameState.Serialize();

        var gro = GameState.MakeGuessResultOptimizer();
        var possibilities = Settings.FilterHiddenWords(gro);
        string? bestGuess;

        if (possibilities.Count <= 0)
            bestGuess = null;
        else
        {
            if (_cancellationTokenSource.IsCancellationRequested)
                return;

            try
            {
                bestGuess = await Worker.Value.Service.RunAsync(x =>
                    x.GetBestGuess(serializedGameState)
                    );
            }
            catch (Exception e)
            {
                var message = GetInnerMostMessage(e);

                Console.WriteLine(message);
                return;
            }
        }

        if (_cancellationTokenSource.IsCancellationRequested)
            return;
        Suggestion = new SuggestionData(bestGuess??"", possibilities);


        StateHasChanged();

        static string GetInnerMostMessage(Exception e)
        {
            if (e.InnerException is not null) return GetInnerMostMessage(e.InnerException);
            return e.Message;
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _cancellationTokenSource?.Cancel();
        if (Worker is not null)
        {
            Worker.Value.Service.DisposeAsync();
            Worker.Value.Worker.DisposeAsync();
        }
    }

}