@using System.Collections.Immutable
<div class="mud-input-control mud-input-input-control" @onkeydown="OnKeyDown">
    <MudButtonGroup>

        @for (var i = 0; i < Settings.WordLength; i++)
        {
            var i1 = i;
            char c;
            Variant variant;
            Color color;
            var val = Text[i];

            if (Placeholder?.Length > i && Text.All(x => !x.HasValue))
            {
                c = Placeholder[i];
                variant = Variant.Text;
                color = GetColorFunc(i1, c);
            }
            else if (val.HasValue)
            {
                c = val.Value;
                color = GetColorFunc(i1, c);
                variant = Variant.Filled;
            }
            else
            {
                c = BlankChar; //Special blank character
                color = Color.Dark;
                variant = Variant.Outlined;
            }
            <MudChip
                Color="@color"
                Variant="@variant"
                Label="@(CurrentIndex != i)"
                Style="margin: 1px"
                Size="Size" OnClick="() => ChipClicked(i1)">
                @c
            </MudChip>
        }
        <MudIconButton
            Icon="@Icons.Filled.Add"
            OnClick="AddAction"
            Disabled="IsAddDisabled"/>
    </MudButtonGroup>


    @if (!string.IsNullOrWhiteSpace(HelperText))
    {
        <div class="mud-input-control-helper-container">
            <p class="mud-input-helper-text">
                <div class="d-flex">
                    <div class="mr-auto">@HelperText</div>
                </div>
            </p>
        </div>
    }

</div>


@code {

    [Parameter]
    [EditorRequired]
    public ImmutableArray<char?> Text { get; set; }

    [Parameter]
    [EditorRequired]
    public EventCallback<ImmutableArray<char?>> TextChanged { get; set; }

    [Parameter]
    public string? HelperText { get; set; }

    [Parameter]
    public string? Placeholder { get; set; }

    [Parameter]
    [EditorRequired]
    public bool IsAddDisabled { get; set; }

    [Parameter]
    [EditorRequired]
    public Func<Task> AddAction { get; set; }

    [Parameter]
    [EditorRequired]
    public GameSettings Settings { get; set; }

    [Parameter]
    [EditorRequired]
    public Size Size { get; set; }

    [Parameter]
    [EditorRequired]
    public Func<int, char, Color> GetColorFunc { get; set; }

    public int CurrentIndex { get; private set; } = 0;
    public const char BlankChar = ' ';

    //private MudTextField<string> _textField;

    private async Task OnKeyDown(KeyboardEventArgs obj)
    {
        const string enterKey = "Enter";
        const string backspaceKey = "Backspace";
        const string deleteKey = "Delete";

        if (obj.Key.Equals(enterKey))
        {
            if(!IsAddDisabled)
                await AddAction();
        }
            
        else if (obj.Key.Equals(backspaceKey))
        {
            await ClearPrevious();
        }
        else if (obj.Key.Equals(deleteKey))
        {
            await ClearNext();
        }
        else if (obj.Key.Length == 1 && char.IsLetter(obj.Key.Single()))
        {
            await InputLetter(char.ToUpperInvariant(obj.Key.Single()));
        }
    }

    public async Task ClearPrevious()
    {
        if (CurrentIndex == 0)
            return;
        CurrentIndex -= 1;
        await ClearCurrent();
    }

    public async Task ClearNext()
    {
        await ClearCurrent();
        CurrentIndex++;
        CurrentIndex %= Settings.WordLength;
    }

    public async Task ClearCurrent()
    {
        Text = Text.SetItem(CurrentIndex, null);
        await TextChanged.InvokeAsync(Text);
    }

    public async Task InputLetter(char c)
    {
        CurrentIndex %= Settings.WordLength;
        
        Text = Text.SetItem(CurrentIndex, c);
        CurrentIndex++;
        CurrentIndex %= Settings.WordLength;
        await TextChanged.InvokeAsync(Text);
    }

    private void ChipClicked(int index)
    {
        CurrentIndex = index;
    }

}