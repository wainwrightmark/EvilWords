@using BlafettisLib
@using System.Collections.Immutable
@inject Blazored.LocalStorage.ILocalStorageService _localStorage

<CurrentWordComponent @ref="_currentWordComponent"
                      Text="@UserGuess"
                      TextChanged="s=> UserGuess=s"
                      AddAction="@AddGuess"
                      CurrentIndex="@SelectedIndex"
                      CurrentIndexChanged="i => SelectedIndex=i"
                      MaxLength="Settings.WordLength"

/>

<MudList Dense="true">
    @foreach (var guessResult in GameState.PreviousGuesses)
    {
        <MudListItem >
            <GuessComponent Size="Size.Large" GuessResult="guessResult" />

        </MudListItem>
    }
    
    @for (var i = GameState.PreviousGuesses.Count + 1; i <= Settings.MaxRounds; i++)
    {
        <MudListItem>
            <EmptyGuessComponent Size="Size.Large" WordLength="@Settings.WordLength" />
        </MudListItem>
    }

    @if (IsGameOver)
    {
        <MudListItem>
            @if (GameState.IsWin)
            {
                <MudText Typo="Typo.h6">You are victorious!</MudText>
            }
            else if(History.Results.Any())
            {
                <MudText Typo="Typo.h6">Sorry, honey, the word was</MudText>
                <MudText Typo="Typo.h2">@History.Results.Last().HiddenWord</MudText>
            }
        </MudListItem>

        <MudListItem>
            <MudButton OnClick="Restart">New Game</MudButton>
        </MudListItem>

        <MudListItem>
            <ChartComponent History="History" />
        </MudListItem>
    }
    else
    {
        const string inputListItemKey = "inputListItem";

        

        <MudListItem @key="inputListItemKey">
        
            <WordInputComponent
                CurrentWordComponent ="@_currentWordComponent"
                Settings="@Settings"
                IsAddDisabled="!IsGoodGuess()"
                Size="Size.Large"
                GetColorFunc="GetColor"
                HelperText="@($"Type a {Settings.WordLength} letter word")"
                />

        </MudListItem>

        <MudListItem>
            <MudButton OnClick="Restart">Restart</MudButton>
        </MudListItem>
    }
    
    

</MudList>
<Blafettis @ref="Blafettis" duration="8000" elementCount="150" />

@code{


    public RunHistory History => _history;
    public GameState GameState => _gameState;

    private RunHistory _history = RunHistory.Empty;
    private GameState _gameState = GameState.Empty;

    public CurrentWordComponent _currentWordComponent;

    [Parameter]
    [EditorRequired]
    public bool IsEvil { get; set; }

    private string RunHistoryKey => (IsEvil? "Evil": "Nice") +Settings.WordLength + "RunHistory";
        
    private string GameStateKey => (IsEvil? "Evil": "Nice") +Settings.WordLength + "GameState";

    private string HiddenWordKey => (IsEvil? "Evil": "Nice") +Settings.WordLength + "HiddenWord";

    private string _hiddenWord = "";

    private async Task SetHistory(RunHistory runHistory)
    {
        await _localStorage.SetItemAsync(RunHistoryKey, runHistory);
        _history = runHistory;
    }
    
    private async Task SetGameState(GameState gameState, string hw)
    {
        await _localStorage.SetItemAsStringAsync(GameStateKey, gameState.Serialize());
        _gameState = gameState;

        if (!IsEvil)
        {
            await _localStorage.SetItemAsStringAsync(HiddenWordKey, hw);
            _hiddenWord = hw;
        }
    }

    private async Task GetGameStateFromLocalStorage()
    {
        var serialized = await _localStorage.GetItemAsStringAsync(GameStateKey);

        if (serialized is not null)
        {
            _gameState = GameStateSerialization.Deserialize(serialized);
            var hw = await _localStorage.GetItemAsStringAsync(HiddenWordKey);
            _hiddenWord = hw;
        }
            
        else //Set initial game state
        {
            _gameState = GameState.Empty;

            if(!IsEvil)
                _hiddenWord = Settings.GetRandomHiddenWord(_gameState.MakeGuessResultOptimizer(), Random, false);

            UserGuess = Settings.GetRandomHiddenWord(null, Random, true)
                .Select(x=> x as char?)
                .ToImmutableArray();

            await AddGuess();
        }
    }

    private async Task GetHistoryFromLocalStorage()
    {
        var stuff = await _localStorage.GetItemAsync<RunHistory>(RunHistoryKey);

        if (stuff is not null)
            _history = stuff;
        else
        {
            _history = new RunHistory(ArraySegment<GameResult>.Empty);
        }
    }

    public GameSettings Settings { get; } = GameSettings.FiveLetter;

    public bool IsGameOver => GameState.IsWin || GameState.PreviousGuesses.Count >= Settings.MaxRounds;

    public Color GetColor(int index, char c) => GameState.GetColor(index, c);
    
    public ImmutableArray<char?> UserGuess { get; set; }

    public int SelectedIndex;

    private void ResetUserGuess() => UserGuess = Enumerable.Repeat(null as char?, Settings.WordLength).ToImmutableArray();

    public Random Random = new();
#pragma warning disable CS8618
    protected Blafettis Blafettis;
#pragma warning restore CS8618


    /// <inheritdoc />
    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        ResetUserGuess();
        await GetGameStateFromLocalStorage();
        await GetHistoryFromLocalStorage();
    }
    

    public async Task Restart()
    {
        string hiddenWord;
        if (IsEvil)
        {
            var gro = GameState.MakeGuessResultOptimizer();
            hiddenWord = Settings.GetRandomHiddenWord(gro, Random, true);
        }
        else
        {
            hiddenWord = _hiddenWord;
        }

        
        if (!IsGameOver)
        {
            var guessCount = GameState.IsWin ? GameState.PreviousGuesses.Count : null as int?;
            var gameResult = new GameResult(guessCount, hiddenWord);
            await SetHistory(History.Add(gameResult));
        }

        UserGuess = hiddenWord.Select(x=> x as char?).ToImmutableArray(); //The first guess of the next game is the previous hidden word
        var newHiddenWord = IsEvil?
            "" :
            Settings.GetRandomHiddenWord(null, Random, false);
        
        await SetGameState(GameState.Empty, newHiddenWord);
        await AddGuess();
    }


    public string? GetRealGuess()
    {
        if (UserGuess.Any(x => !x.HasValue)) return null;

        var guess  = new string(UserGuess.Select(x=>x.Value)
            .Where(char.IsLetter) .ToArray()).Trim().ToUpperInvariant();

        if(guess.Length != Settings.WordLength || !Settings.PossibleGuesses.Contains(guess))
            return null;

        return guess;
    }

    public bool IsGoodGuess() => GetRealGuess() is not null;

    private async Task AddGuess()
    {
        var guess = GetRealGuess();
        if (guess is null) return;

        var newGuessResult =
            IsEvil?
            GuessResult.GetWorstCase(guess, GameState, Settings):
            GuessResult.ScoreWord(_hiddenWord, guess)
        ;
        
        await SetGameState(GameState.Add(newGuessResult), _hiddenWord);
        ResetUserGuess();

        if (GameState.IsWin)
        {
            var gameResult = new GameResult(GameState.PreviousGuesses.Count, guess);
            await SetHistory(History.Add(gameResult));
            Blafettis.RaiseConfetti();  // raise confetti via method
        }

        if (GameState.PreviousGuesses.Count >= Settings.MaxRounds)
        {
            var gro = GameState.MakeGuessResultOptimizer();
            var hiddenWord = Settings.GetRandomHiddenWord(gro, Random, true);
            var gameResult = new GameResult(null, hiddenWord);
            await SetHistory(History.Add(gameResult));
        }
        StateHasChanged();
    }

    private async Task OnInputKeyPress(KeyboardEventArgs obj)
    {
        const string enterKey = "Enter";

        if (obj.Key.Equals(enterKey))
            await AddGuess();
    }

}